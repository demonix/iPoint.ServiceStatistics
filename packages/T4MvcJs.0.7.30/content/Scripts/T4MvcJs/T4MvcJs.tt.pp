<#@ template language="C#v3.5" debug="true" hostspecific="true" #>
<#@ output extension=".js" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ assembly name="$(ProjectDir)$(OutDir)$(TargetFileName)" #>
<#@ assembly name="$(ProjectDir)$(OutDir)T4MvcJs.RoutesHandler.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ assembly name="System.Web" #>
<#@ assembly name="System.Web.Mvc" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Web" #>
<#@ import namespace="System.Web.Mvc" #>
<#@ import namespace="System.Web.Routing" #>
<#@ import namespace="System.Collections.Specialized" #>
<#@ import namespace="System.Reflection" #>
<# // To debug, uncomment the next two lines !! 
//System.Diagnostics.Debugger.Launch();
//System.Diagnostics.Debugger.Break();
#>
<#
var currentAssembly = new T4MvcJs.T4Proxy().GetType().AssemblyQualifiedName.Replace("T4MvcJs.T4Proxy", "");
PrepareDataToRender(this); 
SetupRoutes();
#>
/*  
*		THIS FILE WAS GENERATED BY A TOOL!!!
*
*		Do not change anything here, your changes will be overwritten!
*		Change T4MvcJs.tt template instead
*/

var Constants = {
<#
var firstConstantsController = true;
foreach (var controller in Classes()) {
	var first = true;
	var childFound = false;
	var controllerType = System.Type.GetType(controller.FullName + currentAssembly);
	var controllerFields = controllerType.GetFields();
	foreach (var child in controller.Children.OfType<CodeVariable>()) {
		if (child.IsConstant && child.Access == vsCMAccess.vsCMAccessPublic) {	
			childFound = true;
			RenderHeaderOrComma(controller.Name, ref first, ref firstConstantsController);
			var value = controllerFields.First(x => x.Name == child.Name).GetRawConstantValue();
			#>

			<#= child.Name #>: "<#=value#>"<#
		}
	}

	if (childFound) {#> 
	}<# } 
	}
	#>

};

var MvcActions = {
<#
var firstActionsController = true;
foreach (var controller in Classes()) {
	if (!IsController(controller))
		continue;
	if (!firstActionsController) {#>,<# } #>


	<#=controller.Name #>: { 	
		Name: "<#= ControllerName(controller)#>",
		Actions: {	<# 
			var firstMethod = true;
			foreach (var method in GetMethods(controller)) {
				if (!IsActionMethod(method))
					continue;

				if (!firstMethod) {#>,<# } #>

			<#= method.Name #>: "<#= method.Name.ToLower() #>"<#

				firstMethod = false;
			}#>
		
		}<#

	var first = false;
	foreach (var method in GetMethods(controller)) {
		if (!IsActionMethod(method))
			continue;

		var parameters = "";
		var outputConditionals = "";
		var parameterNames = new List<string>();
            foreach (var methodParamInfo in GetMethodParams(method))
            {
				var processed = false;
				//parse complex parameters
				if (methodParamInfo.Parameter.Type.TypeKind == EnvDTE.vsCMTypeRef.vsCMTypeRefCodeType) {
					if (methodParamInfo.Parameter.Type.CodeType.InfoLocation != vsCMInfoLocation.vsCMInfoLocationExternal) {
						foreach (var modelProperty in methodParamInfo.Parameter.Type.CodeType.Children.OfType<CodeProperty>()) {
							AddParameter(modelProperty.Name, ref outputConditionals, ref parameters);
							parameterNames.Add(modelProperty.Name);
						}
						processed = true;
					}
				}

				if (!processed)
				{
					AddParameter(methodParamInfo.Name, ref outputConditionals, ref parameters);
					parameterNames.Add(methodParamInfo.Name);
				}
            }
			var url = UrlGenerator.GenerateUrl(ControllerName(controller), method.Name, parameterNames.ToArray());

			if (!first) {#>,<# } #>
			

		<#= method.Name #>: function(<#= parameters #>) {
			var url = "<#=url#>";
<#= outputConditionals #>
			return url.replace(/([?&]+$)/g, "");
		}<#
		first = false;
	}
	#> 
	   
	}<# 
	firstActionsController = false;
	} #>

};

<#+ 
const string ControllerSuffix = "Controller";

static DTE Dte;
static Project Project;
static string AppRoot;
static TextTransformation TT;
static string T4FileName;
static string T4Folder;
static string GeneratedCode = @"GeneratedCode(""T4MVCJS"", ""2.0"")";
static float MvcVersion;
static string HtmlStringType;
static Microsoft.CSharp.CSharpCodeProvider codeProvider = new Microsoft.CSharp.CSharpCodeProvider();
static List<CodeClass2> MyClasses;

static T4MvcJs.RoutesHandler.UrlGenerator UrlGenerator;


void RenderHeaderOrComma(string controllerName, ref bool first, ref bool firstController) {
	if (!first) 
	{
		#>,<#+ 
	}
	else 
	{
		if (!firstController) {#>,
<#+     } #>

	<#=controllerName #>: { 	<#+
		firstController = false;	
	} 
	first = false;
}

IEnumerable<CodeClass2> Classes() {
	return MyClasses;
}

string ControllerName(CodeClass2 controller) {
	return controller.Name.Replace("Controller", "").ToLower();
}

void AddParameter(string parameterName, ref string outputConditionals, ref string parameters) {
				if (parameters != "") { parameters += ", "; }
	            parameters += parameterName;
				outputConditionals += String.Format(@"			if ({0}) {{ 
				url = url.replace(""{{{0}}}"", {0});
			}} else {{
				url = url.replace(""{0}={{{0}}}"", """").replace(""?&"",""?"").replace(""&&"",""&"");
			}}
", parameterName, parameterName);

}

IEnumerable<CodeNamespace> GetNamespaces(ProjectItem projectItem)
{
	var result = new List<CodeNamespace>();
	if (projectItem != null && projectItem.FileCodeModel != null && projectItem.FileCodeModel.CodeElements != null)
	{
		foreach (CodeElement codeElement in projectItem.FileCodeModel.CodeElements)
		{
			CodeImport codeImport = codeElement as CodeImport;
			var codeNamespace = codeElement as CodeNamespace;
			if (codeNamespace != null)
			{
				result.Add(codeNamespace);
			}
		}
	}
    return result;
}


List<CodeClass2> GetClasses(ProjectItem projectItem)
{
    var codeNamespaces = GetNamespaces(projectItem);
	var result = new List<CodeClass2>();
	foreach (var codeNamespace in codeNamespaces) 
	{
		foreach (CodeElement codeElement in codeNamespace.Children)
		{
			var codeClass = codeElement as CodeClass2;
			if (codeClass != null)
			{
				result.Add(codeClass);
			}
		}
	}
	if (projectItem != null && projectItem.FileCodeModel != null && projectItem.FileCodeModel.CodeElements != null)
	{        
		foreach (CodeElement codeElement in projectItem.FileCodeModel.CodeElements)
		{
			var codeClass = codeElement as CodeClass2;
			if (codeClass != null)
			{
				result.Add(codeClass);
			}
		}
	}
    return result;
}

void MyProcessProject()  {
	 MyClasses = new List<CodeClass2>();
	 foreach (ProjectItem projectItem in Project.ProjectItems)
     {
			MyProcessProjectItem(projectItem);
     }
}

void MyProcessProjectItem(ProjectItem projectItem) {
	if (projectItem.Name.EndsWith(".tt"))
		return;

	if (projectItem.FileCodeModel == null)
    {
        MyProcessProjectItems(projectItem);
    } 
	else 
	{
		MyProcessClasses(projectItem);
	}
}
void MyProcessProjectItems(ProjectItem mainProjectItem)
{
    foreach (ProjectItem projectItem in mainProjectItem.ProjectItems)
    {
        MyProcessProjectItem(projectItem);
    }
}


void MyProcessClasses(ProjectItem projectItem) {
	foreach (var type in GetClasses(projectItem))
    {
		if (type.FullName.Contains("Controller")) {
			MyClasses.Add(type);
		}
    }
}

void SetupRoutes() {
	var routes = T4MvcJs.T4Proxy.GetRoutes();
	UrlGenerator = new T4MvcJs.RoutesHandler.UrlGenerator(routes);
}

void PrepareDataToRender(TextTransformation tt) {
    TT = tt;
    T4FileName = Path.GetFileName(Host.TemplateFile);
    T4Folder = Path.GetDirectoryName(Host.TemplateFile);
    
    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null) {
        Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null) {
        throw new Exception("T4MVC can only execute through the Visual Studio host");
    }

    Project = GetProjectContainingT4File(Dte);

    if (Project == null) {
        Error("Could not find the VS Project containing the T4 file.");
        return;
    }

	MyProcessProject();
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);


    return projectItem.ContainingProject;
}


static bool IsController(CodeClass2 type) {
    // Ignore any class which name doesn't end with "Controller"
    if (!type.FullName.EndsWith(ControllerSuffix)) return false;

    for (; type.FullName != "System.Web.Mvc.Controller"; type = (CodeClass2)type.Bases.Item(1)) {
        if (type.Bases.Count == 0)
            return false;
    }
    return true;
}

// Return all the CodeFunction2 in the CodeElements collection
static IEnumerable<CodeFunction2> GetMethods(CodeClass2 codeClass) {
    // Only look at regular method (e.g. ignore things like contructors)
    return codeClass.Members.OfType<CodeFunction2>()
        .Where(f => f.FunctionKind == vsCMFunction.vsCMFunctionFunction);
}


// Find an attribute of a given type on an attribute collection
static CodeAttribute2 GetAttribute(CodeElements attributes, string attributeType) {
    for (int i = 1; i <= attributes.Count; i++) {
        var attrib = (CodeAttribute2)attributes.Item(i);
        if (attrib.FullName == attributeType) {
            return attrib;
        }
    }
    return null;
}

// Find a method with a given name
static CodeFunction2 GetMethod(CodeClass2 codeClass, string name) {
    return GetMethods(codeClass).FirstOrDefault(f => f.Name == name);
}


static List<MethodParamInfo> GetMethodParams(CodeFunction2 method) {
    var parameters = new List<MethodParamInfo>();

    // Can be null when an custom ActionResult has no ctor
    if (method == null)
        return parameters;

    // Process all the parameters
    foreach (var p in method.Parameters.OfType<CodeParameter2>()) {
        // Note: if the param name starts with @ (e.g. to escape a keyword), we need to trim that
        string routeNameExpression = "\"" + p.Name.TrimStart('@') + "\"";

        // If there is a [Bind(Prefix = "someName")] attribute, use it
        if (p.InfoLocation != vsCMInfoLocation.vsCMInfoLocationExternal) {
            var attrib = GetAttribute(p.Attributes, "System.Web.Mvc.BindAttribute");
            if (attrib != null) {
                var arg = attrib.Arguments.OfType<CodeAttributeArgument>().FirstOrDefault(a => a.Name == "Prefix");
                if (arg != null)
                    routeNameExpression = arg.Value;
            }
        }
            
        parameters.Add(
            new MethodParamInfo() {
                Name = p.Name,
                RouteNameExpression = routeNameExpression,
                Type = p.Type.AsString,
				Parameter = p
            });
    }
	return parameters;
}

static bool IsActionMethod(CodeFunction2 method) {
	// Ignore non-public methods
    if (method.Access != vsCMAccess.vsCMAccessPublic)
        return false;

    // Ignore methods that are marked as not being actions
    if (GetAttribute(method.Attributes, "System.Web.Mvc.NonActionAttribute") != null)
        return false;

    // Ignore methods that are marked as Obsolete
    if (GetAttribute(method.Attributes, "System.ObsoleteAttribute") != null)
        return false;

    // Ignore generic methods
    if (method.IsGeneric)
        return false;

    // This takes care of avoiding generic types which cause method.Type.CodeType to blow up
    if (method.Type.TypeKind != vsCMTypeRef.vsCMTypeRefCodeType)
        return false;

    // We only support action methods that return an ActionResult derived type
    if (!method.Type.CodeType.get_IsDerivedFrom("System.Web.Mvc.ActionResult")) {
        return false;
    }

    // Ignore async completion methods as they can't really be used in T4MVC, and can cause issues.
    // See http://stackoverflow.com/questions/5419173/t4mvc-asynccontroller
    if (method.Name.EndsWith("Completed", StringComparison.OrdinalIgnoreCase))
        return false;

	return true;
}

class MethodParamInfo {
    public string Name { get; set; }
    public string RouteNameExpression { get; set; }
    public string Type { get; set; }
	public CodeParameter2 Parameter { get; set; }
}


#>